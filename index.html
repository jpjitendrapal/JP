<!DOCTYPE html>

<html>
<head>
	<script
		src="https://code.jquery.com/jquery-3.1.1.min.js"
		integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
		crossorigin="anonymous"></script>
		
<script src="https://use.fontawesome.com/1d8b1d7aa2.js"></script>
		
<link rel="stylesheet" type="text/css" href="build/CSS/styles.css">
<script src="build/JS/scripts.js"></script>
<!--End of Zendesk Chat Script-->
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
	Hello
	Webpack and Browserify do pretty much the same job, which is bundling your modules to be used in a browser environment (though you can target other environments, like bundling your server-side ES6 code for Node). For example the Node module is a feature, which doesn't exist in the browser, and ES 6 modules are not implemented in any browser yet, which is why things need to be bundled. However, they differ in many ways, Webpack offers many tools by default (e.g. code splitting), while Browserify can do this only after downloading plugins, but using both leads to very similar results. It comes down to personal preference (I am used to Webpack). Webpack is not a task runner, it is just processor of your files (it processes them by so called loaders) run directly from CLI or by a task runner.

webpack-dev-server provides something like Browsersync - a server, where you can deploy your app and verify your FE developing progress immediately by dev-server automatically refreshing the browser or even propagating changes without it with hot deploy (e.g. React components).

I've been using Gulp for its conciseness and easy task writing, but have later found out I need neither Gulp nor Grunt at all. Everything I have ever needed could have been done using npm scripts to run 3rd-party tools through their API. Choosing between Gulp, Grunt or npm scripts depends on your taste, JS experience and experience of developers working with you.

While tasks in Gulp (or Grunt maybe) are easy to read even for people not so familiar with JS, it is yet another tool to require and learn, and I personally prefer to narrow my dependencies and make things simple. On the other hand, replacing these tasks with combination of npm scripts and run files (where configuration and execution function of tools like Webpack lies) is more challenging. But in the majority of cases, those three are equal in terms of results.

As for the examples, I suggest you have a look at this React starter project, which shows you nice combination of npm scripts, Webpack and Browsersync. You can find those npm scripts in package.json in the root folder, in a property named scripts. There you will mostly encounter commands like babel-node tools/run start. Babel-node is a CLI tool (not ment for production use), which at first compiles ES6 file tools/run (run.js file located in tools) - basically a runner utility. This runner takes a function as an argument and runs it, which in this case is start - another utility (start.js) responsible for bundling source files (both client and server), starting node-express server and subsequently Browsersync, which serves as a proxy for propagating development changes to browser.

Speaking more precisely, start.js imports Webpack config for client, manipulates it to add hot module replacement capabilities, then creates both client and server side bundles, starts node server through yet another utility named runServer.js and after successful start inits Browsersync, which looks something like this.
	<!--place holder for all the views-->
	<div class="views"></div>
</body>
</html>
